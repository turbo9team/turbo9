// [TURBO9_HEADER_START]
//////////////////////////////////////////////////////////////////////////////
//                          Turbo9 Microprocessor IP
//////////////////////////////////////////////////////////////////////////////
// Website: www.turbo9.org
// Contact: team[at]turbo9[dot]org
//////////////////////////////////////////////////////////////////////////////
// [TURBO9_LICENSE_START]
// BSD-1-Clause
//
// Copyright (c) 2020-2023
// Kevin Phillipson
// Michael Rywalt
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS AND CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// [TURBO9_LICENSE_END]
//////////////////////////////////////////////////////////////////////////////
// Engineer: Kevin Phillipson
// Description: Non-aligned 16-bit shared program/data pipelined Wishbone
// memory interface
//
//////////////////////////////////////////////////////////////////////////////
// History:
// 07.14.2023 - Kevin Phillipson
//   File header added
//
//////////////////////////////////////////////////////////////////////////////
// [TURBO9_HEADER_END]

/////////////////////////////////////////////////////////////////////////////
//                                MODULE
/////////////////////////////////////////////////////////////////////////////
module turbo9_wishbone_2x8bit
#(
  parameter REGISTER_WB_OUTPUTS = 1
)
(
  // Inputs: Clock & Reset
  input          RST_I,
  input          CLK_I,

  // External Wishbone Interface (Even bytes)
  input    [4:0] EVEN_TGD_I,
  output   [4:0] EVEN_TGD_O,
  //
  input    [7:0] EVEN_DAT_I,
  input          EVEN_ACK_I,
  input          EVEN_STALL_I,
  output  [14:0] EVEN_ADR_O,
  output   [7:0] EVEN_DAT_O,
  output         EVEN_WE_O, 
  output         EVEN_STB_O,
  output         EVEN_CYC_O,

  // External Wishbone Interface (Odd bytes)
  input    [7:0] ODD_DAT_I,
  input          ODD_ACK_I,
  input          ODD_STALL_I,
  output  [14:0] ODD_ADR_O,
  output   [7:0] ODD_DAT_O,
  output         ODD_WE_O, 
  output         ODD_STB_O,
  output         ODD_CYC_O,

  // Data Memory Interface
  input   [15:0] DMEM_DAT_I,
  output  [15:0] DMEM_DAT_O,
  input   [15:0] DMEM_ADR_I,
  output         DMEM_BUSY_O,
  input          DMEM_REQ_I,
  input          DMEM_REQ_WIDTH_I,
  input          DMEM_WE_I,
  output         DMEM_RD_ACK_O,
  output         DMEM_WR_ACK_O,
  output         DMEM_ACK_WIDTH_O,

  // Program Memory Interface
  output  [15:0] PMEM_DAT_O,
  input   [15:0] PMEM_ADR_I,
  output         PMEM_BUSY_O,
  input          PMEM_RD_REQ_I,
  //input          PMEM_REQ_WIDTH_I,
  output         PMEM_RD_ACK_O
  //output         PMEM_ACK_WIDTH_O

);

/////////////////////////////////////////////////////////////////////////////
//                           INPUTS / OUTPUTS
/////////////////////////////////////////////////////////////////////////////
// Inputs: Clock & Reset
//input        RST_I;  // Reset. Active high and synchronized to CLK_I
//input        CLK_I;  // Clock

// Wishbone Inputs 
//input [15:0] DAT_I;  // The data input array [DAT_I()] is used to pass
                       // binary data.
                       // 
//input        ACK_I;  // The acknowledge input [ACK_I], when asserted,
                       // indicates the normal termination of a bus cycle.
                       // Also see the [ERR_I] and [RTY_I] signal descriptions.
                       //
//input        STALL_I;// The pipeline stall input [STALL_I] indicates that
                       // current slave is not able to accept the transfer
                       // in the transaction queue.
                       //
//input        ERR_I;  // The error input [ERR_I] indicates an abnormal
                       // cycle termination. The source of the error, and
                       // the response generated by the MASTER is defined
                       // by the IP core supplier. Also see the [ACK_I] and
                       // [RTY_I] signal descriptions.
                       //
//input        RTY_I;  // The retry input [RTY_I] indicates that the interface
                       // is not ready to accept or send data, and that the
                       // cycle should be retried. When and how the cycle is
                       // retried is defined by the IP core supplier. Also
                       // see the [ERR_I] and [RTY_I] signal descriptions.
                       //
// Wishbone Outputs
//output [15:0] ADR_O; // The address output array [ADR_O()] is used to pass
                       // a binary address. The higher array boundary is
                       // specific to the address width of the core, and the
                       // lower array boundary is determined by the data port
                       // size and granularity. For example the array size on
                       // a 32-bit data port with BYTE granularity is
                       // [ADR_O(n..2)]. In some cases (such as FIFO
                       // interfaces) the array may not be present on the
                       // interface.
                       // 
//output [15:0] DAT_O; // The data output array [DAT_O()] is used to pass
                       // binary data. The array boundaries are determined by
                       // the port size, with a maximum port size of 64-bits
                       // (e.g. [DAT_I(63..0)]). Also see the [DAT_I()] and
                       // [SEL_O()] signal descriptions.
                       // 
//output        WE_O;  // The write enable output [WE_O] indicates whether
                       // the current local bus cycle is a READ or WRITE
                       // cycle. The signal is negated during READ cycles,
                       // and is asserted during WRITE cycles.
                       // 
//output        STB_O; //  The strobe output [STB_O] indicates a valid data
                       // transfer cycle. It is used to qualify various other
                       // signals on the interface such as [SEL_O()]. The
                       // SLAVE asserts either the [ACK_I], [ERR_I] or
                       // [RTY_I] signals in response to every assertion of
                       // the [STB_O] signal.
                       // 
//output        CYC_O; // The cycle output [CYC_O], when asserted, indicates
                       // that a valid bus cycle is in progress. The signal
                       // is asserted for the duration of all bus cycles. For
                       // example, during a BLOCK transfer cycle there can be
                       // multiple data transfers. The [CYC_O] signal is
                       // asserted during the first data transfer, and remains
                       // asserted until the last data transfer. The [CYC_O]
                       // signal is useful for interfaces with multi-port
                       // interfaces (such as dual port memories). In these
                       // cases, the [CYC_O] signal requests use of a common
                       // bus from an arbiter.

/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
//                             INTERNAL SIGNALS
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////// WIDTH_I defines
//
// This must match the MSB of the *_REG_SEL control vectors
localparam  WIDTH_16 =  1'b0;
localparam  WIDTH_8  =  1'b1;


reg   [14:0]  even_adr_o_reg;
reg   [14:0]  even_adr_o_nxt;
localparam    even_adr_o_rst = 15'h0000;

reg    [7:0]  even_dat_o_reg;
reg    [7:0]  even_dat_o_nxt;
localparam    even_dat_o_rst = 8'h00;

reg           even_we_o_reg;
reg           even_we_o_nxt;
localparam    even_we_o_rst = 1'b0;
           
reg           even_stb_o_reg;
reg           even_stb_o_nxt;
localparam    even_stb_o_rst = 1'b0;
           
reg   [14:0]  odd_adr_o_reg;
reg   [14:0]  odd_adr_o_nxt;
localparam    odd_adr_o_rst = 15'h0000;

reg    [7:0]  odd_dat_o_reg;
reg    [7:0]  odd_dat_o_nxt;
localparam    odd_dat_o_rst = 8'h00;

reg           odd_we_o_reg;
reg           odd_we_o_nxt;
localparam    odd_we_o_rst = 1'b0;
           
reg           odd_stb_o_reg;
reg           odd_stb_o_nxt;
localparam    odd_stb_o_rst = 1'b0;
           
reg           cyc_o_reg;
wire          cyc_o_nxt;
localparam    cyc_o_rst = 1'b0;

wire          even_tag_dmem_rd_i;
reg           even_tag_dmem_rd_o_reg;
reg           even_tag_dmem_rd_o_nxt;
localparam    even_tag_dmem_rd_o_rst = 1'b0;

wire          even_tag_dmem_wr_i;
reg           even_tag_dmem_wr_o_reg;
reg           even_tag_dmem_wr_o_nxt;
localparam    even_tag_dmem_wr_o_rst = 1'b0;

wire          even_tag_pmem_rd_i;
reg           even_tag_pmem_rd_o_reg;
reg           even_tag_pmem_rd_o_nxt;
localparam    even_tag_pmem_rd_o_rst = 1'b0;

wire          even_tag_adr0_i;
reg           even_tag_adr0_o_reg;
reg           even_tag_adr0_o_nxt;
localparam    even_tag_adr0_o_rst = 1'b0;

wire          even_tag_width_i;
reg           even_tag_width_o_reg;
reg           even_tag_width_o_nxt;
localparam    even_tag_width_o_rst = WIDTH_16;

reg    [2:0]  pending_cnt_reg;
wire   [2:0]  pending_cnt_nxt;
localparam    pending_cnt_rst = 3'b000;
wire   [2:0]  pending_cnt_term;

reg   [15:0]  dmem_dat;
reg   [15:0]  pmem_dat;

/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
//               MEMORY ACCESS TAG LOGIC & WISHBONE OUTPUT REGISTERS
/////////////////////////////////////////////////////////////////////////////
//
// STALL_I should be generated externally and must be _registered_
//
wire [14:0] dmem_even_adr_inc = DMEM_ADR_I[15:1] + {14'd0, DMEM_ADR_I[0]};
wire [14:0] dmem_odd_adr      = DMEM_ADR_I[15:1];
wire        dmem_adr0         = DMEM_ADR_I[0];
//
wire [14:0] pmem_even_adr_inc = PMEM_ADR_I[15:1] + {14'd0, PMEM_ADR_I[0]};
wire [14:0] pmem_odd_adr      = PMEM_ADR_I[15:1];
wire        pmem_adr0         = PMEM_ADR_I[0];

wire        stall_i   = (EVEN_STALL_I|ODD_STALL_I);
wire        stb_o_nxt = (even_stb_o_nxt|odd_stb_o_nxt);
wire        ack_i     = (EVEN_ACK_I|ODD_ACK_I);

always @* begin
  //
  // Defaults
  //
  even_tag_dmem_rd_o_nxt  = 1'b0;
  even_tag_dmem_wr_o_nxt  = 1'b0;
  even_tag_pmem_rd_o_nxt  = 1'b0;
  even_tag_adr0_o_nxt     = dmem_adr0;
  even_tag_width_o_nxt    = WIDTH_16;
  //
  even_stb_o_nxt  = 1'b0;
  even_we_o_nxt   = 1'b0;
  even_adr_o_nxt  = dmem_even_adr_inc;
  even_dat_o_nxt  = DMEM_DAT_I[15:8];
  //
  odd_stb_o_nxt  = 1'b0;
  odd_we_o_nxt   = 1'b0;
  odd_adr_o_nxt  = dmem_odd_adr;
  odd_dat_o_nxt  = DMEM_DAT_I[ 7:0];


  if (DMEM_REQ_I) begin
    even_tag_dmem_rd_o_nxt = ~DMEM_WE_I;
    even_tag_dmem_wr_o_nxt =  DMEM_WE_I;
    even_tag_adr0_o_nxt    =  dmem_adr0;
    //
    if (DMEM_REQ_WIDTH_I == WIDTH_8) begin
      even_tag_width_o_nxt  =  WIDTH_8;
      even_stb_o_nxt        = ~dmem_adr0;
      even_we_o_nxt         = ~dmem_adr0 & DMEM_WE_I;
      //
      odd_stb_o_nxt         =  dmem_adr0;
      odd_we_o_nxt          =  dmem_adr0 & DMEM_WE_I;
    end else begin
      even_tag_width_o_nxt  = WIDTH_16;
      even_stb_o_nxt        = 1'b1;
      even_we_o_nxt         = DMEM_WE_I;
      //
      odd_stb_o_nxt         = 1'b1;
      odd_we_o_nxt          = DMEM_WE_I;
    end
    //
    even_adr_o_nxt = dmem_even_adr_inc;
    odd_adr_o_nxt  = dmem_odd_adr;
    //
  end else if (PMEM_RD_REQ_I) begin
    even_tag_pmem_rd_o_nxt = 1'b1;
    even_tag_adr0_o_nxt    = pmem_adr0;
    //
    //if (PMEM_REQ_WIDTH_I == WIDTH_8) begin
    //  even_tag_width_o_nxt = WIDTH_8;
    //  even_stb_o_nxt       = ~pmem_adr0;
    //  //
    //  odd_stb_o_nxt        =  pmem_adr0;
    //end else begin
      even_tag_width_o_nxt = WIDTH_16;
      even_stb_o_nxt       = 1'b1;
      //
      odd_stb_o_nxt        = 1'b1;
    //end
    //
    even_we_o_nxt  = 1'b0;
    odd_we_o_nxt   = 1'b0;
    //
    even_adr_o_nxt = pmem_even_adr_inc;
    odd_adr_o_nxt  = pmem_odd_adr;
    //
  end
  //
  case ({DMEM_REQ_WIDTH_I, dmem_adr0})
    //
    {WIDTH_16, 1'b0} : begin
      even_dat_o_nxt = DMEM_DAT_I[15:8];
      odd_dat_o_nxt  = DMEM_DAT_I[ 7:0];
    end
    //
    {WIDTH_16, 1'b1} : begin
      even_dat_o_nxt = DMEM_DAT_I[ 7:0];
      odd_dat_o_nxt  = DMEM_DAT_I[15:8];
    end
    //
    {WIDTH_8,  1'b0} : begin
      even_dat_o_nxt = DMEM_DAT_I[ 7:0];
      odd_dat_o_nxt  = DMEM_DAT_I[15:8]; //INFO: Minimize logic?
    end
    //
    {WIDTH_8,  1'b1} : begin
      even_dat_o_nxt = DMEM_DAT_I[15:8]; //INFO: Dont care!
      odd_dat_o_nxt  = DMEM_DAT_I[ 7:0];
    end
    //
  endcase
end 

assign cyc_o_nxt = (pending_cnt_nxt != 3'b000) ? 1'b1 : 1'b0;

assign pending_cnt_term = ( stb_o_nxt & ~ack_i) ? 3'b001 : // inc
                          (~stb_o_nxt &  ack_i) ? 3'b111 : // dec
                                                  3'b000 ; // hold
assign pending_cnt_nxt  = pending_cnt_reg + pending_cnt_term;


// Program Memory Mux
always @* begin
  //
  // Defaults
  //
  pmem_dat[15:8] = EVEN_DAT_I;
  pmem_dat[ 7:0] = ODD_DAT_I;
  case (even_tag_adr0_i)
    //
    1'b0 : begin  // PMEM read, even address, 16bit or 8bit
      pmem_dat[15:8] = EVEN_DAT_I;
      pmem_dat[ 7:0] = ODD_DAT_I;
    end
    //
    1'b1 : begin  // PMEM read, odd address, 16bit or 8bit
      pmem_dat[15:8] = ODD_DAT_I;
      pmem_dat[ 7:0] = EVEN_DAT_I;
    end
    //
  endcase
end


// Data Memory Mux
always @* begin
  //
  // Defaults
  //
  dmem_dat[15:8] = EVEN_DAT_I;
  dmem_dat[ 7:0] = ODD_DAT_I;
  case ({even_tag_adr0_i, even_tag_width_i})
    //
    {1'b0, WIDTH_16} : begin  // DMEM read, even address, 16bit
      dmem_dat[15:8] = EVEN_DAT_I;
      dmem_dat[ 7:0] = ODD_DAT_I;
    end
    //
    {1'b1, WIDTH_16} : begin  // DMEM read, odd address, 16bit
      dmem_dat[15:8] = ODD_DAT_I;
      dmem_dat[ 7:0] = EVEN_DAT_I;
    end
    //
    {1'b0, WIDTH_8} : begin  // DMEM read, even address, 8bit
      dmem_dat[15:8] = 8'h00;
      dmem_dat[ 7:0] = EVEN_DAT_I;
    end
    //
    {1'b1, WIDTH_8} : begin  // DMEM read, odd address, 8bit
      dmem_dat[15:8] = 8'h00;
      dmem_dat[ 7:0] = ODD_DAT_I;
    end
    //
  endcase
end


always @(posedge CLK_I, posedge RST_I) begin

  if (RST_I) begin
    even_adr_o_reg          <= even_adr_o_rst;
    even_dat_o_reg          <= even_dat_o_rst;
    even_we_o_reg           <= even_we_o_rst;
    even_stb_o_reg          <= even_stb_o_rst;
    odd_adr_o_reg           <= odd_adr_o_rst;
    odd_dat_o_reg           <= odd_dat_o_rst;
    odd_we_o_reg            <= odd_we_o_rst;
    odd_stb_o_reg           <= odd_stb_o_rst;
    cyc_o_reg               <= cyc_o_rst;
    even_tag_dmem_rd_o_reg  <= even_tag_dmem_rd_o_rst;
    even_tag_dmem_wr_o_reg  <= even_tag_dmem_wr_o_rst;
    even_tag_pmem_rd_o_reg  <= even_tag_pmem_rd_o_rst;
    even_tag_adr0_o_reg     <= even_tag_adr0_o_rst;
    even_tag_width_o_reg    <= even_tag_width_o_rst;
    pending_cnt_reg         <= pending_cnt_rst;
  end else begin
    if (~stall_i) begin
      even_adr_o_reg          <= even_adr_o_nxt;
      even_dat_o_reg          <= even_dat_o_nxt;
      even_we_o_reg           <= even_we_o_nxt;
      even_stb_o_reg          <= even_stb_o_nxt;
      odd_adr_o_reg           <= odd_adr_o_nxt;
      odd_dat_o_reg           <= odd_dat_o_nxt;
      odd_we_o_reg            <= odd_we_o_nxt;
      odd_stb_o_reg           <= odd_stb_o_nxt;
      cyc_o_reg               <= cyc_o_nxt;
      even_tag_dmem_rd_o_reg  <= even_tag_dmem_rd_o_nxt;
      even_tag_dmem_wr_o_reg  <= even_tag_dmem_wr_o_nxt;
      even_tag_pmem_rd_o_reg  <= even_tag_pmem_rd_o_nxt;
      even_tag_adr0_o_reg     <= even_tag_adr0_o_nxt;
      even_tag_width_o_reg    <= even_tag_width_o_nxt;
      pending_cnt_reg         <= pending_cnt_nxt;
    end
  end
end
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//                        EXTERNAL WISHBONE INTERFACE 
/////////////////////////////////////////////////////////////////////////////
generate
  if (REGISTER_WB_OUTPUTS) begin
    assign ODD_ADR_O = odd_adr_o_reg;
    assign ODD_DAT_O = odd_dat_o_reg;
    assign ODD_WE_O  = odd_we_o_reg ; 
    assign ODD_STB_O = odd_stb_o_reg;
    assign ODD_CYC_O = cyc_o_reg;

    assign EVEN_ADR_O = even_adr_o_reg;
    assign EVEN_DAT_O = even_dat_o_reg;
    assign EVEN_WE_O  = even_we_o_reg ; 
    assign EVEN_STB_O = even_stb_o_reg;
    assign EVEN_CYC_O = cyc_o_reg;

    assign EVEN_TGD_O[4] = even_tag_dmem_rd_o_reg;
    assign EVEN_TGD_O[3] = even_tag_dmem_wr_o_reg;
    assign EVEN_TGD_O[2] = even_tag_pmem_rd_o_reg;
    assign EVEN_TGD_O[1] = even_tag_adr0_o_reg;
    assign EVEN_TGD_O[0] = even_tag_width_o_reg;
  end else begin
    assign ODD_ADR_O = odd_adr_o_nxt;
    assign ODD_DAT_O = odd_dat_o_nxt;
    assign ODD_WE_O  = odd_we_o_nxt; 
    assign ODD_STB_O = odd_stb_o_nxt;
    assign ODD_CYC_O = cyc_o_nxt;

    assign EVEN_ADR_O = even_adr_o_nxt;
    assign EVEN_DAT_O = even_dat_o_nxt;
    assign EVEN_WE_O  = even_we_o_nxt; 
    assign EVEN_STB_O = even_stb_o_nxt;
    assign EVEN_CYC_O = cyc_o_nxt;

    assign EVEN_TGD_O[4] = even_tag_dmem_rd_o_nxt;
    assign EVEN_TGD_O[3] = even_tag_dmem_wr_o_nxt;
    assign EVEN_TGD_O[2] = even_tag_pmem_rd_o_nxt;
    assign EVEN_TGD_O[1] = even_tag_adr0_o_nxt;
    assign EVEN_TGD_O[0] = even_tag_width_o_nxt;
  end
endgenerate


assign even_tag_dmem_rd_i = EVEN_TGD_I[4];
assign even_tag_dmem_wr_i = EVEN_TGD_I[3];
assign even_tag_pmem_rd_i = EVEN_TGD_I[2];
assign even_tag_adr0_i    = EVEN_TGD_I[1];
assign even_tag_width_i   = EVEN_TGD_I[0];
/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
//                        PROG & DATA MEM OUTPUTS
/////////////////////////////////////////////////////////////////////////////
// Data Memory Interface
assign DMEM_DAT_O         = dmem_dat;
assign DMEM_BUSY_O        = stall_i;
assign DMEM_RD_ACK_O      = even_tag_dmem_rd_i & ~stall_i;
assign DMEM_WR_ACK_O      = even_tag_dmem_wr_i & ~stall_i;
assign DMEM_ACK_WIDTH_O   = even_tag_width_i;

// Program Memory Interface
assign PMEM_DAT_O         = pmem_dat;
assign PMEM_BUSY_O        = DMEM_REQ_I | stall_i;
assign PMEM_RD_ACK_O      = even_tag_pmem_rd_i & ~stall_i;
//assign PMEM_ACK_WIDTH_O   = even_tag_width_i;
//
/////////////////////////////////////////////////////////////////////////////

endmodule

