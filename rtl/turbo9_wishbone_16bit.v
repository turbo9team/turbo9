// [TURBO9_HEADER_START]
//////////////////////////////////////////////////////////////////////////////
//                          Turbo9 Microprocessor IP
//////////////////////////////////////////////////////////////////////////////
// Website: www.turbo9.org
// Contact: team[at]turbo9[dot]org
//////////////////////////////////////////////////////////////////////////////
// [TURBO9_LICENSE_START]
// BSD-1-Clause
//
// Copyright (c) 2020-2023
// Kevin Phillipson
// Michael Rywalt
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS AND CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// [TURBO9_LICENSE_END]
//////////////////////////////////////////////////////////////////////////////
// Engineer: Kevin Phillipson
// Description: Shared 8-bit program/data pipelined Wishbone memory interface
//
//////////////////////////////////////////////////////////////////////////////
// History:
// 07.14.2023 - Kevin Phillipson
//   File header added
//
//////////////////////////////////////////////////////////////////////////////
// [TURBO9_HEADER_END]

/////////////////////////////////////////////////////////////////////////////
//                                MODULE
/////////////////////////////////////////////////////////////////////////////
module turbo9_wishbone_16bit
#(
  parameter REGISTER_WB_OUTPUTS = 1 // Register Wishbone Ouputs: True=1, False=0
)
(
  // Inputs: Clock & Reset
  input          RST_I,
  input          CLK_I,

  // External Wishbone Interface
  input   [15:0] DAT_I,
  input    [4:0] TGD_I,
  input          ACK_I,
  input          STALL_I,
  output  [15:1] ADR_O,
  output  [15:0] DAT_O,
  output   [1:0] SEL_O,
  output   [4:0] TGD_O,
  output         WE_O, 
  output         STB_O,
  output         CYC_O,

  // Data Memory Interface
  input   [15:0] DMEM_DAT_I,
  output  [15:0] DMEM_DAT_O,
  input   [15:0] DMEM_ADR_I,
  output         DMEM_BUSY_O,
  input          DMEM_REQ_I,
  input          DMEM_REQ_WIDTH_I,
  input          DMEM_WE_I,
  output         DMEM_RD_ACK_O,
  output         DMEM_WR_ACK_O,
  output         DMEM_ACK_WIDTH_O,

  // Program Memory Interface
  output  [15:0] PMEM_DAT_O,
  input   [15:0] PMEM_ADR_I,
  output         PMEM_BUSY_O,
  input          PMEM_RD_REQ_I,
  output         PMEM_RD_ACK_O,
  output         PMEM_ACK_WIDTH_O

);

/////////////////////////////////////////////////////////////////////////////
//                           INPUTS / OUTPUTS
/////////////////////////////////////////////////////////////////////////////
// Inputs: Clock & Reset
//input        RST_I;  // Reset. Active high and synchronized to CLK_I
//input        CLK_I;  // Clock

// Wishbone Inputs 
//input  [7:0] DAT_I;  // The data input array [DAT_I()] is used to pass
                       // binary data.
                       // 
//input        ACK_I;  // The acknowledge input [ACK_I], when asserted,
                       // indicates the normal termination of a bus cycle.
                       // Also see the [ERR_I] and [RTY_I] signal descriptions.
                       //
//input        STALL_I;// The pipeline stall input [STALL_I] indicates that
                       // current slave is not able to accept the transfer
                       // in the transaction queue.
                       //
//input        ERR_I;  // The error input [ERR_I] indicates an abnormal
                       // cycle termination. The source of the error, and
                       // the response generated by the MASTER is defined
                       // by the IP core supplier. Also see the [ACK_I] and
                       // [RTY_I] signal descriptions.
                       //
//input        RTY_I;  // The retry input [RTY_I] indicates that the interface
                       // is not ready to accept or send data, and that the
                       // cycle should be retried. When and how the cycle is
                       // retried is defined by the IP core supplier. Also
                       // see the [ERR_I] and [RTY_I] signal descriptions.
                       //
// Wishbone Outputs
//output [15:0] ADR_O; // The address output array [ADR_O()] is used to pass
                       // a binary address. The higher array boundary is
                       // specific to the address width of the core, and the
                       // lower array boundary is determined by the data port
                       // size and granularity. For example the array size on
                       // a 32-bit data port with BYTE granularity is
                       // [ADR_O(n..2)]. In some cases (such as FIFO
                       // interfaces) the array may not be present on the
                       // interface.
                       // 
//output  [7:0] DAT_O; // The data output array [DAT_O()] is used to pass
                       // binary data. The array boundaries are determined by
                       // the port size, with a maximum port size of 64-bits
                       // (e.g. [DAT_I(63..0)]). Also see the [DAT_I()] and
                       // [SEL_O()] signal descriptions.
                       // 
//output        WE_O;  // The write enable output [WE_O] indicates whether
                       // the current local bus cycle is a READ or WRITE
                       // cycle. The signal is negated during READ cycles,
                       // and is asserted during WRITE cycles.
                       // 
//output        STB_O; //  The strobe output [STB_O] indicates a valid data
                       // transfer cycle. It is used to qualify various other
                       // signals on the interface such as [SEL_O()]. The
                       // SLAVE asserts either the [ACK_I], [ERR_I] or
                       // [RTY_I] signals in response to every assertion of
                       // the [STB_O] signal.
                       // 
//output        CYC_O; // The cycle output [CYC_O], when asserted, indicates
                       // that a valid bus cycle is in progress. The signal
                       // is asserted for the duration of all bus cycles. For
                       // example, during a BLOCK transfer cycle there can be
                       // multiple data transfers. The [CYC_O] signal is
                       // asserted during the first data transfer, and remains
                       // asserted until the last data transfer. The [CYC_O]
                       // signal is useful for interfaces with multi-port
                       // interfaces (such as dual port memories). In these
                       // cases, the [CYC_O] signal requests use of a common
                       // bus from an arbiter.

//output        SEL_O: // The select output array [SEL_O()] indicates where
                       // valid data is expected on the [DAT_I()] signal array
                       // during READ cycles, and where it is placed on the
                       // [DAT_O()] signal array during WRITE cycles. The array
                       // boundaries are determined by the granularity of a
                       // port. For example, if 8-bit granularity is used on a
                       // 64-bit port, then there would be an array of eight
                       // select signals with boundaries of [SEL_O(7..0)]. Each
                       // individual select signal correlates to one of eight
                       // active bytes on the 64-bit data port.



/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
//                             INTERNAL SIGNALS
/////////////////////////////////////////////////////////////////////////////

  
//////////////////////////////////////// WIDTH_I defines
//
// This must match the MSB of the *_REG_SEL control vectors
localparam  WIDTH_16 =  1'b0;
localparam  WIDTH_8  =  1'b1;

reg   [15:1]  adr_o_reg;
reg   [15:1]  adr_o_nxt;
localparam    adr_o_rst = 15'h0000;

reg   [15:0]  dat_o_reg;
reg   [15:0]  dat_o_nxt;
localparam    dat_o_rst = 16'h0000;

reg    [7:0]  lsb_byte_reg;
wire   [7:0]  lsb_byte_nxt;
localparam    lsb_byte_rst = 8'h00;

reg    [7:0]  msb_byte_reg;
wire   [7:0]  msb_byte_nxt;
localparam    msb_byte_rst = 8'h00;

reg    [1:0]  sel_o_reg;
reg    [1:0]  sel_o_nxt;
localparam    sel_o_rst = 2'b00;

reg           we_o_reg;
reg           we_o_nxt;
localparam    we_o_rst = 1'b0;
           
reg           stb_o_reg;
reg           stb_o_nxt;
localparam    stb_o_rst = 1'b0;
           
reg           cyc_o_reg;
wire          cyc_o_nxt;
localparam    cyc_o_rst = 1'b0;

wire          tag_dmem_rd_i;
reg           tag_dmem_rd_o_cycle1_reg;
reg           tag_dmem_rd_o_cycle1_nxt;
localparam    tag_dmem_rd_o_cycle1_rst = 1'b0;
reg           tag_dmem_rd_o_reg;
reg           tag_dmem_rd_o_nxt;
localparam    tag_dmem_rd_o_rst = 1'b0;

wire          tag_dmem_wr_i;
reg           tag_dmem_wr_o_cycle1_reg;
reg           tag_dmem_wr_o_cycle1_nxt;
localparam    tag_dmem_wr_o_cycle1_rst = 1'b0;
reg           tag_dmem_wr_o_reg;
reg           tag_dmem_wr_o_nxt;
localparam    tag_dmem_wr_o_rst = 1'b0;

wire          tag_pmem_rd_i;
reg           tag_pmem_rd_o_reg;
reg           tag_pmem_rd_o_nxt;
localparam    tag_pmem_rd_o_rst = 1'b0;


wire          tag_width_i;
reg           tag_width_o_reg;
reg           tag_width_o_nxt;
localparam    tag_width_o_rst = 1'b0;

wire          tag_adr0_i;
reg           tag_adr0_o_reg;
reg           tag_adr0_o_nxt;
localparam    tag_adr0_o_rst = 1'b0;

reg           wishbone_state_reg;
reg           wishbone_state_nxt;
localparam    WISHBONE_CYCLE0 = 1'b0;
localparam    WISHBONE_CYCLE1 = 1'b1;
wire          wishbone_multicycle = (wishbone_state_reg != WISHBONE_CYCLE0);

reg    [2:0]  pending_cnt_reg;
wire   [2:0]  pending_cnt_nxt;
localparam    pending_cnt_rst = 3'b000;
wire   [2:0]  pending_cnt_term;

wire          ack_width;

reg   [15:0]  dmem_dat;
reg   [15:0]  pmem_dat;

wire   [7:0]  even_byte;
wire   [7:0]  odd_byte;

/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
//                      WISHBONE PIPELINE OUTPUT LOGIC 
/////////////////////////////////////////////////////////////////////////////
//
//

always @* begin
  //
  // Defaults
  //
  tag_dmem_rd_o_nxt = 1'b0;
  tag_dmem_wr_o_nxt = 1'b0;
  tag_pmem_rd_o_nxt = 1'b0;
  //
  tag_dmem_rd_o_cycle1_nxt = 1'b0;
  tag_dmem_wr_o_cycle1_nxt = 1'b0;
  //
  tag_width_o_nxt   = DMEM_REQ_WIDTH_I;
  tag_adr0_o_nxt    = DMEM_ADR_I[0];
  adr_o_nxt         = DMEM_ADR_I[15:1];
  dat_o_nxt[15:8]   = DMEM_DAT_I[15:8];
  dat_o_nxt[ 7:0]   = DMEM_DAT_I[ 7:0];
  sel_o_nxt         = 2'b00;
  we_o_nxt          = 1'b0;
  stb_o_nxt         = 1'b0;
  //
  wishbone_state_nxt = WISHBONE_CYCLE0;

  case (wishbone_state_reg)
    WISHBONE_CYCLE0: begin
      //
      case ({DMEM_ADR_I[0], DMEM_REQ_WIDTH_I})
        //
        {1'b0, WIDTH_16} : begin  // even address, 16bit
          dat_o_nxt[15:8] = DMEM_DAT_I[15:8]; // msb
          dat_o_nxt[ 7:0] = DMEM_DAT_I[ 7:0]; // lsb
        end
        //
        {1'b1, WIDTH_16} : begin  // odd address, 16bit
          //dat_o_nxt[15:8] = DMEM_DAT_I[7:0]; // don't care
          dat_o_nxt[ 7:0] = DMEM_DAT_I[15:8]; // msb
        end
        //
        {1'b0, WIDTH_8} : begin  // even address, 8bit
          dat_o_nxt[15:8] = DMEM_DAT_I[ 7:0]; // byte
          //dat_o_nxt[ 7:0] = DMEM_DAT_I[15:8]; // don't care
        end
        //
        {1'b1, WIDTH_8} : begin  // odd address, 8bit
          //dat_o_nxt[15:8] = DMEM_DAT_I[15:0]; // don't care
          dat_o_nxt[ 7:0] = DMEM_DAT_I[ 7:0]; // byte
        end
      endcase
      //
      if (DMEM_REQ_I) begin
        //
        case ({DMEM_ADR_I[0], DMEM_REQ_WIDTH_I})
          //
          {1'b0, WIDTH_16} : begin  // even address, 16bit
            sel_o_nxt       = 2'b11;
            //
            tag_dmem_rd_o_nxt  = ~DMEM_WE_I;
            tag_dmem_wr_o_nxt  =  DMEM_WE_I;
            wishbone_state_nxt =  WISHBONE_CYCLE0;
          end
          //
          {1'b1, WIDTH_16} : begin  // odd address, 16bit
            sel_o_nxt       = 2'b01;
            //
            tag_dmem_rd_o_cycle1_nxt = ~DMEM_WE_I;
            tag_dmem_wr_o_cycle1_nxt =  DMEM_WE_I;
            wishbone_state_nxt       =  WISHBONE_CYCLE1;
          end
          //
          {1'b0, WIDTH_8} : begin  // even address, 8bit
            sel_o_nxt       = 2'b10;
            //
            tag_dmem_rd_o_nxt  = ~DMEM_WE_I;
            tag_dmem_wr_o_nxt  =  DMEM_WE_I;
            wishbone_state_nxt =  WISHBONE_CYCLE0;
          end
          //
          {1'b1, WIDTH_8} : begin  // odd address, 8bit
            sel_o_nxt       = 2'b01;
            //
            tag_dmem_rd_o_nxt  = ~DMEM_WE_I;
            tag_dmem_wr_o_nxt  =  DMEM_WE_I;
            wishbone_state_nxt =  WISHBONE_CYCLE0;
          end
        endcase
        //
        tag_width_o_nxt   = DMEM_REQ_WIDTH_I;
        tag_adr0_o_nxt    = DMEM_ADR_I[0];
        adr_o_nxt         = DMEM_ADR_I[15:1];
        we_o_nxt          = DMEM_WE_I;
        stb_o_nxt         = 1'b1;
        //
      end else if (PMEM_RD_REQ_I) begin
        case (PMEM_ADR_I[0])
          1'b0 : begin // even address, 16bit
            tag_width_o_nxt = WIDTH_16;
            sel_o_nxt = 2'b11;
          end
          1'b1 : begin // odd address, 8bit
            tag_width_o_nxt = WIDTH_8;
            sel_o_nxt = 2'b01;
          end
        endcase
        tag_pmem_rd_o_nxt     = 1'b1;
        wishbone_state_nxt    = WISHBONE_CYCLE0;
        //end
        //
        tag_adr0_o_nxt  = PMEM_ADR_I[0];
        adr_o_nxt       = PMEM_ADR_I[15:1] ;
        we_o_nxt        = 1'b0;            
        stb_o_nxt       = 1'b1;            
        //
      end else begin
        wishbone_state_nxt = WISHBONE_CYCLE0;
      end
      //
    end

    WISHBONE_CYCLE1: begin // multicycle state

      tag_dmem_rd_o_nxt  = tag_dmem_rd_o_cycle1_reg;
      tag_dmem_wr_o_nxt  = tag_dmem_wr_o_cycle1_reg;
      tag_pmem_rd_o_nxt  = 1'b0;
      tag_width_o_nxt    = WIDTH_16;
      tag_adr0_o_nxt     = 1'b1;
      adr_o_nxt          = adr_o_reg + 15'h0001;       
      dat_o_nxt[15:8]    = lsb_byte_reg; // lsb
      //dat_o_nxt[ 7:0]  = // don't care
      sel_o_nxt          = 2'b10;
      we_o_nxt           = we_o_reg;         
      stb_o_nxt          = 1'b1;
      wishbone_state_nxt = WISHBONE_CYCLE0;  

    end
  endcase
end 

assign lsb_byte_nxt     = DMEM_DAT_I[7:0];

assign cyc_o_nxt        = (pending_cnt_nxt != 3'b000) ? 1'b1 : 1'b0;

assign pending_cnt_term = ( stb_o_nxt & ~ACK_I) ? 3'b001 : // inc
                          (~stb_o_nxt &  ACK_I) ? 3'b111 : // dec
                                                  3'b000 ; // hold
assign pending_cnt_nxt  = pending_cnt_reg + pending_cnt_term;


always @(posedge CLK_I, posedge RST_I) begin

 if (RST_I) begin
    adr_o_reg                <= adr_o_rst;
    dat_o_reg                <= dat_o_rst;
    sel_o_reg                <= sel_o_rst;
    we_o_reg                 <= we_o_rst;
    stb_o_reg                <= stb_o_rst;
    cyc_o_reg                <= cyc_o_rst;
    tag_dmem_rd_o_reg        <= tag_dmem_rd_o_rst;
    tag_dmem_wr_o_reg        <= tag_dmem_wr_o_rst;
    tag_pmem_rd_o_reg        <= tag_pmem_rd_o_rst;
    tag_dmem_rd_o_cycle1_reg <= tag_dmem_rd_o_cycle1_rst;
    tag_dmem_wr_o_cycle1_reg <= tag_dmem_wr_o_cycle1_rst;
    tag_width_o_reg          <= tag_width_o_rst;
    tag_adr0_o_reg           <= tag_adr0_o_rst;
    pending_cnt_reg          <= pending_cnt_rst;
    lsb_byte_reg             <= lsb_byte_rst;
    wishbone_state_reg       <= WISHBONE_CYCLE0;  
  end else begin
    if (~STALL_I) begin // STALL_I should be generated externally and must be _registered_
      adr_o_reg                <= adr_o_nxt;
      dat_o_reg                <= dat_o_nxt;
      sel_o_reg                <= sel_o_nxt;
      we_o_reg                 <= we_o_nxt;
      stb_o_reg                <= stb_o_nxt;
      cyc_o_reg                <= cyc_o_nxt;
      tag_dmem_rd_o_reg        <= tag_dmem_rd_o_nxt;
      tag_dmem_wr_o_reg        <= tag_dmem_wr_o_nxt;
      tag_pmem_rd_o_reg        <= tag_pmem_rd_o_nxt;
      tag_dmem_rd_o_cycle1_reg <= tag_dmem_rd_o_cycle1_nxt;
      tag_dmem_wr_o_cycle1_reg <= tag_dmem_wr_o_cycle1_nxt;
      tag_width_o_reg          <= tag_width_o_nxt;
      tag_adr0_o_reg           <= tag_adr0_o_nxt;
      pending_cnt_reg          <= pending_cnt_nxt;
      lsb_byte_reg             <= lsb_byte_nxt;
      wishbone_state_reg       <= wishbone_state_nxt;  
    end
  end
end


generate
  if (REGISTER_WB_OUTPUTS) begin
    //
    assign ADR_O       = adr_o_reg;
    assign DAT_O       = dat_o_reg;
    assign SEL_O       = sel_o_reg;
    assign WE_O        = we_o_reg ; 
    assign STB_O       = stb_o_reg;
    assign CYC_O       = cyc_o_reg;
    //
    assign TGD_O[4]    = tag_dmem_rd_o_reg;
    assign TGD_O[3]    = tag_dmem_wr_o_reg;
    assign TGD_O[2]    = tag_pmem_rd_o_reg;
    assign TGD_O[1]    = tag_adr0_o_reg;
    assign TGD_O[0]    = tag_width_o_reg;
    //
  end else begin
    //
    assign ADR_O       = adr_o_nxt;
    assign DAT_O       = dat_o_nxt;
    assign SEL_O       = sel_o_nxt;
    assign WE_O        = we_o_nxt ; 
    assign STB_O       = stb_o_nxt;
    assign CYC_O       = cyc_o_nxt;
    //
    assign TGD_O[4]    = tag_dmem_rd_o_nxt;
    assign TGD_O[3]    = tag_dmem_wr_o_nxt;
    assign TGD_O[2]    = tag_pmem_rd_o_nxt;
    assign TGD_O[1]    = tag_adr0_o_nxt;
    assign TGD_O[0]    = tag_width_o_nxt;
    //
  end
endgenerate


//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//                  WISHBONE PIPELINE FEEDBACK INPUT LOGIC
/////////////////////////////////////////////////////////////////////////////

assign tag_dmem_rd_i  = TGD_I[4];
assign tag_dmem_wr_i  = TGD_I[3];
assign tag_pmem_rd_i  = TGD_I[2];
assign tag_adr0_i     = TGD_I[1];
assign tag_width_i    = TGD_I[0];

assign even_byte    = DAT_I[15:8];
assign odd_byte     = DAT_I[ 7:0];

assign msb_byte_nxt = DAT_I[7:0];

always @(posedge CLK_I, posedge RST_I) begin
  if (RST_I) begin
    msb_byte_reg    <= msb_byte_rst; // INFO: Could remove if data_mem_ctrl register was used
  end else begin
    if (~STALL_I) begin // STALL_I should be generated externally and must be _registered_
      msb_byte_reg  <= msb_byte_nxt;
    end
  end
end


// Program Memory Mux
always @* begin
  //
  // Defaults
  //
  pmem_dat[15:8] = even_byte;
  pmem_dat[ 7:0] = odd_byte;
  //
  case (tag_adr0_i)
    //
    1'b0 : begin  // PMEM read, even address, 16bit
      pmem_dat[15:8] = even_byte;
      pmem_dat[ 7:0] = odd_byte;
    end
    //
    1'b1 : begin  // PMEM read, odd address, 8bit
      pmem_dat[15:8] = odd_byte;
      //pmem_dat[ 7:0] = //Reduce Logic (Dont care for 8bit)
    end
    //
  endcase
end


// Data Memory Mux
always @* begin
  //
  // Defaults
  //
  dmem_dat[15:8] = even_byte;
  dmem_dat[ 7:0] = odd_byte;
  //
  case ({tag_adr0_i, tag_width_i})
    //
    {1'b0, WIDTH_16} : begin  // DMEM read, even address, 16bit
      dmem_dat[15:8] = even_byte;
      dmem_dat[ 7:0] = odd_byte;
    end
    //
    {1'b1, WIDTH_16} : begin  // DMEM read, odd address, 16bit
      dmem_dat[15:8] = msb_byte_reg;
      dmem_dat[ 7:0] = even_byte;
    end
    //
    {1'b0, WIDTH_8} : begin  // DMEM read, even address, 8bit
      dmem_dat[15:8] = 8'h00;
      dmem_dat[ 7:0] = even_byte;
    end
    //
    {1'b1, WIDTH_8} : begin  // DMEM read, odd address, 8bit
      dmem_dat[15:8] = 8'h00;
      dmem_dat[ 7:0] = odd_byte;
    end
    //
  endcase
end

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//                        PROG & DATA MEM OUTPUTS
/////////////////////////////////////////////////////////////////////////////
//
// STALL_I should be generated externally and must be _registered_
//
// Data Memory Interface
assign DMEM_DAT_O       = dmem_dat;
assign DMEM_BUSY_O      =  STALL_I | wishbone_multicycle;
assign DMEM_RD_ACK_O    = ~STALL_I & tag_dmem_rd_i & ~STALL_I;
assign DMEM_WR_ACK_O    = ~STALL_I & tag_dmem_wr_i & ~STALL_I;
assign DMEM_ACK_WIDTH_O = tag_width_i;

// Program Memory Interface
assign PMEM_DAT_O       = pmem_dat;
assign PMEM_BUSY_O      =  STALL_I | DMEM_REQ_I | wishbone_multicycle;
assign PMEM_RD_ACK_O    = ~STALL_I & tag_pmem_rd_i;
assign PMEM_ACK_WIDTH_O = tag_width_i;
//
/////////////////////////////////////////////////////////////////////////////

endmodule

