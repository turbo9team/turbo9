// [TURBO9_HEADER_START]
//////////////////////////////////////////////////////////////////////////////
//                          Turbo9 Microprocessor IP
//////////////////////////////////////////////////////////////////////////////
// Website: www.turbo9.org
// Contact: team[at]turbo9[dot]org
//////////////////////////////////////////////////////////////////////////////
// [TURBO9_LICENSE_START]
// BSD-1-Clause
//
// Copyright (c) 2020-2023
// Kevin Phillipson
// Michael Rywalt
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS AND CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// [TURBO9_LICENSE_END]
//////////////////////////////////////////////////////////////////////////////
// Engineer: Kevin Phillipson
// Description: Shared 8-bit program/data pipelined Wishbone memory interface
//
//////////////////////////////////////////////////////////////////////////////
// History:
// 07.14.2023 - Kevin Phillipson
//   File header added
//
//////////////////////////////////////////////////////////////////////////////
// [TURBO9_HEADER_END]

/////////////////////////////////////////////////////////////////////////////
//                                MODULE
/////////////////////////////////////////////////////////////////////////////
module turbo9_wishbone_8bit
#(
  parameter REGISTER_WB_OUTPUTS = 1
)
(
  // Inputs: Clock & Reset
  input          RST_I,
  input          CLK_I,

  // External Wishbone Interface
  input    [7:0] DAT_I,
  input    [3:0] TGD_I,
  input          ACK_I,
  input          STALL_I,
  output  [15:0] ADR_O,
  output   [7:0] DAT_O,
  output   [3:0] TGD_O,
  output         WE_O, 
  output         STB_O,
  output         CYC_O,

  // Data Memory Interface
  input   [15:0] DMEM_DAT_I,
  output  [15:0] DMEM_DAT_O,
  input   [15:0] DMEM_ADR_I,
  output         DMEM_BUSY_O,
  input          DMEM_REQ_I,
  input          DMEM_REQ_WIDTH_I,
  input          DMEM_WE_I,
  output         DMEM_RD_ACK_O,
  output         DMEM_WR_ACK_O,
  output         DMEM_ACK_WIDTH_O,

  // Program Memory Interface
  output  [15:0] PMEM_DAT_O,
  input   [15:0] PMEM_ADR_I,
  output         PMEM_BUSY_O,
  input          PMEM_RD_REQ_I,
  input          PMEM_REQ_WIDTH_I,
  output         PMEM_RD_ACK_O,
  output         PMEM_ACK_WIDTH_O

);

/////////////////////////////////////////////////////////////////////////////
//                           INPUTS / OUTPUTS
/////////////////////////////////////////////////////////////////////////////
// Inputs: Clock & Reset
//input        RST_I;  // Reset. Active high and synchronized to CLK_I
//input        CLK_I;  // Clock

// Wishbone Inputs 
//input  [7:0] DAT_I;  // The data input array [DAT_I()] is used to pass
                       // binary data.
                       // 
//input        ACK_I;  // The acknowledge input [ACK_I], when asserted,
                       // indicates the normal termination of a bus cycle.
                       // Also see the [ERR_I] and [RTY_I] signal descriptions.
                       //
//input        STALL_I;// The pipeline stall input [STALL_I] indicates that
                       // current slave is not able to accept the transfer
                       // in the transaction queue.
                       //
//input        ERR_I;  // The error input [ERR_I] indicates an abnormal
                       // cycle termination. The source of the error, and
                       // the response generated by the MASTER is defined
                       // by the IP core supplier. Also see the [ACK_I] and
                       // [RTY_I] signal descriptions.
                       //
//input        RTY_I;  // The retry input [RTY_I] indicates that the interface
                       // is not ready to accept or send data, and that the
                       // cycle should be retried. When and how the cycle is
                       // retried is defined by the IP core supplier. Also
                       // see the [ERR_I] and [RTY_I] signal descriptions.
                       //
// Wishbone Outputs
//output [15:0] ADR_O; // The address output array [ADR_O()] is used to pass
                       // a binary address. The higher array boundary is
                       // specific to the address width of the core, and the
                       // lower array boundary is determined by the data port
                       // size and granularity. For example the array size on
                       // a 32-bit data port with BYTE granularity is
                       // [ADR_O(n..2)]. In some cases (such as FIFO
                       // interfaces) the array may not be present on the
                       // interface.
                       // 
//output  [7:0] DAT_O; // The data output array [DAT_O()] is used to pass
                       // binary data. The array boundaries are determined by
                       // the port size, with a maximum port size of 64-bits
                       // (e.g. [DAT_I(63..0)]). Also see the [DAT_I()] and
                       // [SEL_O()] signal descriptions.
                       // 
//output        WE_O;  // The write enable output [WE_O] indicates whether
                       // the current local bus cycle is a READ or WRITE
                       // cycle. The signal is negated during READ cycles,
                       // and is asserted during WRITE cycles.
                       // 
//output        STB_O; //  The strobe output [STB_O] indicates a valid data
                       // transfer cycle. It is used to qualify various other
                       // signals on the interface such as [SEL_O()]. The
                       // SLAVE asserts either the [ACK_I], [ERR_I] or
                       // [RTY_I] signals in response to every assertion of
                       // the [STB_O] signal.
                       // 
//output        CYC_O; // The cycle output [CYC_O], when asserted, indicates
                       // that a valid bus cycle is in progress. The signal
                       // is asserted for the duration of all bus cycles. For
                       // example, during a BLOCK transfer cycle there can be
                       // multiple data transfers. The [CYC_O] signal is
                       // asserted during the first data transfer, and remains
                       // asserted until the last data transfer. The [CYC_O]
                       // signal is useful for interfaces with multi-port
                       // interfaces (such as dual port memories). In these
                       // cases, the [CYC_O] signal requests use of a common
                       // bus from an arbiter.

/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
//                             INTERNAL SIGNALS
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////// WIDTH_I defines
//
// This must match the MSB of the *_REG_SEL control vectors
localparam  WIDTH_16 =  1'b0;
localparam  WIDTH_8  =  1'b1;

reg   [15:0]  adr_o_reg;
reg   [15:0]  adr_o_nxt;
localparam    adr_o_rst = 16'h0000;

reg    [7:0]  dat_o_reg;
reg    [7:0]  dat_o_nxt;
localparam    dat_o_rst = 8'h00;

reg    [7:0]  dat_o_lo_byte_reg;
wire    [7:0] dat_o_lo_byte_nxt;
localparam    dat_o_lo_byte_rst = 8'h00;

reg    [7:0]  dat_i_hi_byte_reg;
wire   [7:0]  dat_i_hi_byte_nxt;
localparam    dat_i_hi_byte_rst = 8'h00;

reg           we_o_reg;
reg           we_o_nxt;
localparam    we_o_rst = 1'b0;
           
reg           stb_o_reg;
reg           stb_o_nxt;
localparam    stb_o_rst = 1'b0;
           
reg           cyc_o_reg;
wire          cyc_o_nxt;
localparam    cyc_o_rst = 1'b0;

wire          tag_dmem_rd_i;
reg           tag_dmem_rd_o_16bit_reg;
reg           tag_dmem_rd_o_16bit_nxt;
localparam    tag_dmem_rd_o_16bit_rst = 1'b0;
reg           tag_dmem_rd_o_reg;
reg           tag_dmem_rd_o_nxt;
localparam    tag_dmem_rd_o_rst = 1'b0;

wire          tag_dmem_wr_i;
reg           tag_dmem_wr_o_16bit_reg;
reg           tag_dmem_wr_o_16bit_nxt;
localparam    tag_dmem_wr_o_16bit_rst = 1'b0;
reg           tag_dmem_wr_o_reg;
reg           tag_dmem_wr_o_nxt;
localparam    tag_dmem_wr_o_rst = 1'b0;

wire          tag_pmem_rd_i;
reg           tag_pmem_rd_o_16bit_reg;
reg           tag_pmem_rd_o_16bit_nxt;
localparam    tag_pmem_rd_o_16bit_rst = 1'b0;
reg           tag_pmem_rd_o_reg;
reg           tag_pmem_rd_o_nxt;
localparam    tag_pmem_rd_o_rst = 1'b0;

wire          tag_16bit_i;
reg           tag_16bit_i_reg;
wire          tag_16bit_i_nxt;
localparam    tag_16bit_i_rst = 1'b0;

wire          tag_16bit_o;
reg           tag_16bit_o_reg;
reg           tag_16bit_o_nxt;
localparam    tag_16bit_o_rst = 1'b0;

reg    [2:0]  pending_cnt_reg;
wire   [2:0]  pending_cnt_nxt;
localparam    pending_cnt_rst = 3'b000;
wire   [2:0]  pending_cnt_term;

wire          ack_width;

/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
//               MEMORY ACCESS TAG LOGIC & WISHBONE OUTPUT REGISTERS
/////////////////////////////////////////////////////////////////////////////
//
// STALL_I should be generated externally and must be _registered_
//

always @* begin
  //
  // Defaults
  //
  tag_dmem_rd_o_nxt = 1'b0;
  tag_dmem_wr_o_nxt = 1'b0;
  tag_pmem_rd_o_nxt = 1'b0;
  //
  tag_dmem_rd_o_16bit_nxt = 1'b0;
  tag_dmem_wr_o_16bit_nxt = 1'b0;
  tag_pmem_rd_o_16bit_nxt = 1'b0;
  //
  tag_16bit_o_nxt = 1'b0;
  //
  adr_o_nxt = DMEM_ADR_I;
  dat_o_nxt = DMEM_DAT_I[ 7:0];
  we_o_nxt  = 1'b0;
  stb_o_nxt = 1'b0;

  case (tag_16bit_o_reg)
    1'b0: begin   // 8bit state
      //
      if (DMEM_REQ_I) begin
        //
        if (DMEM_REQ_WIDTH_I == WIDTH_16) begin
          tag_dmem_rd_o_16bit_nxt = ~DMEM_WE_I;
          tag_dmem_wr_o_16bit_nxt =  DMEM_WE_I;
          tag_16bit_o_nxt         =  1'b1;
        end else begin
          tag_dmem_rd_o_nxt       = ~DMEM_WE_I;
          tag_dmem_wr_o_nxt       =  DMEM_WE_I;
          tag_16bit_o_nxt         =  1'b0;
        end
        //
        adr_o_nxt = DMEM_ADR_I;
        we_o_nxt  = DMEM_WE_I;
        stb_o_nxt = 1'b1;
        //
      end else if (PMEM_RD_REQ_I) begin
        //
        if (PMEM_REQ_WIDTH_I == WIDTH_16) begin
          tag_pmem_rd_o_16bit_nxt = 1'b1;
          tag_16bit_o_nxt       = 1'b1;
        end else begin
          tag_pmem_rd_o_nxt     = 1'b1;
          tag_16bit_o_nxt       = 1'b0;
        end
        //
        adr_o_nxt = PMEM_ADR_I;
        we_o_nxt  = 1'b0;
        stb_o_nxt = 1'b1;
        //
      end else begin
        tag_16bit_o_nxt = 1'b0;
      end
      //
      if (DMEM_REQ_WIDTH_I == WIDTH_16) begin
        dat_o_nxt = DMEM_DAT_I[15:8];
      end else begin
        dat_o_nxt = DMEM_DAT_I[ 7:0];
      end
      //
    end

    1'b1: begin // 16bit state

      tag_dmem_rd_o_nxt = tag_dmem_rd_o_16bit_reg;
      tag_dmem_wr_o_nxt = tag_dmem_wr_o_16bit_reg;
      tag_pmem_rd_o_nxt = tag_pmem_rd_o_16bit_reg;
      tag_16bit_o_nxt   = 1'b0;  
      adr_o_nxt         = adr_o_reg + 16'h0001;       
      dat_o_nxt         = dat_o_lo_byte_reg;        
      we_o_nxt          = we_o_reg;         
      stb_o_nxt         = stb_o_reg;        

    end
  endcase
end 

assign dat_o_lo_byte_nxt = DMEM_DAT_I[7:0];

assign cyc_o_nxt = (pending_cnt_nxt != 3'b000) ? 1'b1 : 1'b0;

assign pending_cnt_term = ( stb_o_nxt & ~ACK_I) ? 3'b001 : // inc
                          (~stb_o_nxt &  ACK_I) ? 3'b111 : // dec
                                                  3'b000 ; // hold
assign pending_cnt_nxt  = pending_cnt_reg + pending_cnt_term;

assign dat_i_hi_byte_nxt = (tag_16bit_i) ? DAT_I : 8'h00;

assign tag_16bit_i_nxt  = tag_16bit_i;
assign ack_width        = (tag_16bit_i_reg) ? WIDTH_16 : WIDTH_8;

always @(posedge CLK_I, posedge RST_I) begin

  if (RST_I) begin
    adr_o_reg               <= adr_o_rst;
    dat_o_reg               <= dat_o_rst;
    we_o_reg                <= we_o_rst;
    stb_o_reg               <= stb_o_rst;
    cyc_o_reg               <= cyc_o_rst;
    tag_dmem_rd_o_reg       <= tag_dmem_rd_o_rst;
    tag_dmem_wr_o_reg       <= tag_dmem_wr_o_rst;
    tag_pmem_rd_o_reg       <= tag_pmem_rd_o_rst;
    tag_dmem_rd_o_16bit_reg <= tag_dmem_rd_o_16bit_rst;
    tag_dmem_wr_o_16bit_reg <= tag_dmem_wr_o_16bit_rst;
    tag_pmem_rd_o_16bit_reg <= tag_pmem_rd_o_16bit_rst;
    tag_16bit_o_reg         <= tag_16bit_o_rst;  
    pending_cnt_reg         <= pending_cnt_rst;
    dat_o_lo_byte_reg       <= dat_o_lo_byte_rst;
    dat_i_hi_byte_reg       <= dat_i_hi_byte_rst;
    tag_16bit_i_reg         <= tag_16bit_i_rst;

  end else begin

    if (~STALL_I) begin
      adr_o_reg               <= adr_o_nxt;
      dat_o_reg               <= dat_o_nxt;
      we_o_reg                <= we_o_nxt;
      stb_o_reg               <= stb_o_nxt;
      cyc_o_reg               <= cyc_o_nxt;
      tag_dmem_rd_o_reg       <= tag_dmem_rd_o_nxt;
      tag_dmem_wr_o_reg       <= tag_dmem_wr_o_nxt;
      tag_pmem_rd_o_reg       <= tag_pmem_rd_o_nxt;
      tag_dmem_rd_o_16bit_reg <= tag_dmem_rd_o_16bit_nxt;
      tag_dmem_wr_o_16bit_reg <= tag_dmem_wr_o_16bit_nxt;
      tag_pmem_rd_o_16bit_reg <= tag_pmem_rd_o_16bit_nxt;
      tag_16bit_o_reg         <= tag_16bit_o_nxt;  
      pending_cnt_reg         <= pending_cnt_nxt;
      dat_o_lo_byte_reg       <= dat_o_lo_byte_nxt;
      dat_i_hi_byte_reg       <= dat_i_hi_byte_nxt;
      tag_16bit_i_reg         <= tag_16bit_i_nxt;
    end

  end
end
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//                                WISHBONE 
/////////////////////////////////////////////////////////////////////////////

generate
  if (REGISTER_WB_OUTPUTS) begin
    //
    assign ADR_O       = adr_o_reg;
    assign DAT_O       = dat_o_reg;
    assign WE_O        = we_o_reg ; 
    assign STB_O       = stb_o_reg;
    assign CYC_O       = cyc_o_reg;
    //
    assign TGD_O[3]    = tag_dmem_rd_o_reg;
    assign TGD_O[2]    = tag_dmem_wr_o_reg;
    assign TGD_O[1]    = tag_pmem_rd_o_reg;
    assign TGD_O[0]    = tag_16bit_o_reg;
    assign tag_16bit_o = tag_16bit_o_reg;
    //
  end else begin
    //
    assign ADR_O       = adr_o_nxt;
    assign DAT_O       = dat_o_nxt;
    assign WE_O        = we_o_nxt ; 
    assign STB_O       = stb_o_nxt;
    assign CYC_O       = cyc_o_nxt;
    //
    assign TGD_O[3]    = tag_dmem_rd_o_nxt;
    assign TGD_O[2]    = tag_dmem_wr_o_nxt;
    assign TGD_O[1]    = tag_pmem_rd_o_nxt;
    assign TGD_O[0]    = tag_16bit_o_nxt;
    assign tag_16bit_o = tag_16bit_o_reg;
    //
  end
endgenerate

assign tag_dmem_rd_i = TGD_I[3];
assign tag_dmem_wr_i = TGD_I[2];
assign tag_pmem_rd_i = TGD_I[1];
assign tag_16bit_i   = TGD_I[0];
/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
//                        PROG & DATA MEM OUTPUTS
/////////////////////////////////////////////////////////////////////////////
// Data Memory Interface
assign DMEM_DAT_O       = {dat_i_hi_byte_reg, DAT_I};
assign DMEM_BUSY_O      = tag_16bit_o | STALL_I;
assign DMEM_RD_ACK_O    = tag_dmem_rd_i & ~STALL_I;
assign DMEM_WR_ACK_O    = tag_dmem_wr_i & ~STALL_I;
assign DMEM_ACK_WIDTH_O = ack_width;

// Program Memory Interface
assign PMEM_DAT_O       = {dat_i_hi_byte_reg, DAT_I}; //FIXME we dont need 16bit for PMEM
assign PMEM_BUSY_O      = DMEM_REQ_I | tag_16bit_o | STALL_I;
assign PMEM_RD_ACK_O    = tag_pmem_rd_i & ~STALL_I;
assign PMEM_ACK_WIDTH_O = ack_width;
//
/////////////////////////////////////////////////////////////////////////////

endmodule

